<?php

/*
 * This file is part of the symfony package.
 * (c) 2004-2006 Fabien Potencier <fabien.potencier@symfony-project.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * sfSecurityConfigHandler allows you to configure action security.
 *
 * @package    symfony
 * @subpackage config
 * @author     Jerome Tamarelle <jtamarelle@groupe-exp.com>
 * @version    SVN: $Id$
 */
class sfServiceConfigHandler extends sfYamlConfigHandler
{
  /**
   * Executes this configuration handler.
   *
   * @param array $configFiles An array of absolute filesystem path to a configuration file
   *
   * @return string Data to be written to a cache file
   */
  public function execute($configFiles)
  {
    $parser = $this->constructParser();
    $dumper = $this->constructDumper();

    $builder = $parser->parse(static::getConfiguration($configFiles));

    $code = $dumper->dump($builder);

    // compile data
    $retval = sprintf(
      "<?php\n".
      "// auto-generated by sfServiceConfigHandler\n".
      "// date: %s\n\n".
      "%s\n\n",
      date('Y/m/d H:i:s'), $code);

    return $retval;
  }

  /**
   * @see sfConfigHandler
   * @inheritdoc
   */
  static public function getConfiguration(array $configFiles)
  {
    $config = static::parseYamls($configFiles);
    $config = static::flattenConfigurationWithEnvironment($config);

    return $config;
  }

  /**
   * @return \sfServiceContainerConfigParserInterface
   */
  private function constructParser()
  {
    // tmp container to construct the parser instance
    $container = new sfServiceContainer();

    $config = $this->parameterHolder->get('parser', [
      'class'     => 'sfServiceContainerConfigParser',
      'arguments' => [],
    ]);
    if (!is_array($config)) {
      throw new InvalidArgumentException('"parser" configuration given is invalid: it should be an hash array');
    }

    try {
      /** @var \sfServiceContainerConfigParserInterface $parser */
      $parser = $container->construct($config['class'], isset($config['arguments']) ? $config['arguments'] : []);
    } catch (\RockSymphony\ServiceContainer\Exceptions\BindingResolutionException $ex) {
      throw new InvalidArgumentException('Cannot construct services.yml parser: ' . $ex->getMessage(), 0, $ex);
    }

    if (!$parser instanceof sfServiceContainerConfigParserInterface) {
      throw new InvalidArgumentException(
        '"parser" class should be an instance of sfServiceContainerConfigParserInterface'
      );
    }

    return $parser;
  }

  /**
   * @return \sfServiceContainerDumperInterface
   */
  private function constructDumper()
  {
    // tmp container to construct the dumper instance
    $container = new sfServiceContainer();

    $config = $this->parameterHolder->get('dumper', [
      'class'     => 'sfServiceContainerDumperPhp',
      'arguments' => [],
    ]);
    if (!is_array($config)) {
      throw new InvalidArgumentException('"dumper" configuration given is invalid: it should be an hash array');
    }

    try {
      /** @var \sfServiceContainerDumperInterface $dumper */
      $dumper = $container->construct($config['class'], isset($config['arguments']) ? $config['arguments'] : []);
    } catch (\RockSymphony\ServiceContainer\Exceptions\BindingResolutionException $ex) {
      throw new InvalidArgumentException('Cannot construct service container dumper: ' . $ex->getMessage(), 0, $ex);
    }

    if (!$dumper instanceof sfServiceContainerDumperInterface) {
      throw new InvalidArgumentException(
        '"dumper" class should be an instance of sfServiceContainerDumperInterface'
      );
    }

    return $dumper;
  }
}
